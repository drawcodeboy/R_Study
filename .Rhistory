10 + 20;
5 - 2;
4 * 5;
10 + 20
5 - 2
4 * 5
10 / 3
10 %/% 3
10 %% 3
2 ** 10
2 ^ 10
sqrt(16)
Sqrt(16)
10 > 5
5 < 10
5 >= 7
6 <= 7
8 == 8
clear
clearPushBack()
10 + 20
5 - 2
4 * 5
10 / 3
10 %/% 3
10 %% 3
2 ** 10
2 ^ 10
sqrt(16)
Sqrt(16)
10 > 5
5 < 10
5 >= 7
6 <= 7
8 == 8
9 != 10
10 > 5 & 5 < 10
c(TRUE, TRUE, FALSE) &c(TRUE, FALSE, TRUE)
5 >= 7 | 6 <= 7
!(8==8)
!0
!10
!-2
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
ls()
a <- 10
b = 20
hap <- a + b
cat(hap, "\n")
ls()
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
ls()
a <- 10
b = 20
hap <- a + b
#cat(hap, "\n")
ls()
cat(hap, "\n")
ls()
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
ls()
a <- 10
b = 20
hap <- a + b
#cat(hap, "\n")
ls()
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
ls()
a <- 10
b = 20
hap <- a + b
cat(hap, "\n")
ls()
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
ls()
a <- 10
b = 20
hap <- a + b
cat(a,'+', b, '=', hap, "\n")
ls()
cat(a,'+', b, '=', hap, "\n")
rm(hap)
ls()
#데이터 형(= 타입)
#기본형 numeric, character, logical
#구조형 scalar, factor, vector < matrix < array
#복합형 list < data.frame < data.table
#special values NULL, NA, NaN, INF
rm(list=ls())
ls()
a <- 10
b = 20
hap <- a + b
cat(a,'+', b, '=', hap, "\n")
ls()
rm(hap)
ls()
a_list = 20
a.so = 10
#하나 이상의 스칼라(=길이가 1인 벡터) 원소들을 갖는 단순한 형태의 집합
#숫자, 문자, 논리형 데이터를 원소(Element)로 사용할 수 있음
#동일한 자료형을 갖는 값들의 집합으로 하나의 열(Column)로 구성됨
#벡터 생성 함수: c(value1, value2 ...), seq(form, to, by), rep(x, times, each)
rm(list = ls())
iv <- c(1, 2, 3)
cv <- c('A', 'B', 'C')
bv <- c(TRUE, FALSE)
fv <- c(1, 2, 3, 4)
t <- c(3.4, 2.5, 8)
icv <- c(iv, cv, bv)
#하나 이상의 스칼라(=길이가 1인 벡터) 원소들을 갖는 단순한 형태의 집합
#숫자, 문자, 논리형 데이터를 원소(Element)로 사용할 수 있음
#동일한 자료형을 갖는 값들의 집합으로 하나의 열(Column)로 구성됨
#벡터 생성 함수: c(value1, value2 ...), seq(form, to, by), rep(x, times, each) (seq = sequence, rep = repeat)
rm(list = ls())
iv <- c(1, 2, 3)
cv <- c('A', 'B', 'C')
bv <- c(TRUE, FALSE)
t <- c(1, 2, 3, 4)
fv <- c(3.4, 2.5, 8)
icv <- c(iv, cv, bv)
#icv 서로 다른 타입을 연결할 경우 문자열 취급되어 연결됨
rm(list = ls())
v1 = seq(1, 5)
v11 = 1:5
v2 = seq(1, 10, 2)
v2 = seq(1, 11, 2)
v3 = seq(1, 10, length = 4)
v3 = seq(1, 11, length = 4) # 4개를 생성한다. 간격은 알아서 조절
rm(list = ls())
v1 = seq(1, 5) # == v11 = 1:5
v2 = seq(1, 10, 2)
v3 = seq(1, 10, length = 4) # 4개를 생성한다. 간격은 알아서 조절
v4 = seq(1, 3, length = 5)
rm(list = ls())
v1 = rep(1, 5)
v2 = rep(1, time = 5)
v3 = rep(3:5, time = 3)
v4 = rep(3:5, each = 2)
v5 = rep(seq(1,5,2), 2)
v5 = rep(seq(1,5,2), 2, 2)
v5 = rep(seq(1,5,2), 2, 2)
v5 = rep(seq(1,5,2), 2, 2)
v5 = rep(seq(1,5,2), 2, 2)
v5 = rep(seq(1,5,2), time = 2, each = 2)
v5 = rep(seq(1,5,2), 2)
rm(list=ls())
v1 <- seq(2, 10, 2)
v2 <- rep(2, 5)
v3 <- v1 + v2
v4 <- v1 %/% v2
v5 <- v1 ^ v2
x <- c(1, 4, 8)
y <- c(2, 3)
z <- t(y)
y
t(y)
m <- x %*% z #행렬곱
ㅡ
m
rm(list=ls())
v3 <- v1 + v2
rm(list=ls())
v1 <- rep(3, 6)
v2 <- c(1, 2, 3)
v3 <- v1 + v2
v1 <- rep(3, 7)
rm(list=ls())
v1 <- rep(3, 7)
v2 <- c(1, 2, 3)
v3 <- v1 + v2
v4 <- v2 + 3
rm(list=ls())
v1 <- rep(3, 6) # 길이(time)가 7일 때, 두 객체의 길이가 서로 배수관계에 있지 않는다고 오류가 뜬다
v2 <- c(1, 2, 3)
v3 <- v1 + v2
v4 <- v2 + 3
#인덱싱
rm(list=ls())
v1 <- seq(1,5)
r1 = v1[3]
v4 = rep(3:5, each = 2)
v5 = rep(seq(1,5,2), 2)
# c, seq, rep
rm(list=ls())
v1 <- seq(1,5)
r1 = v1[3]
r2 = v1[-3]
r3 = v1[2:4]
v1 <- seq(1,5)
r1 = v1[3] #3번 인덱스
r2 = v1[-3] #3번 인덱스를 제외하고 모두
r3 = v1[seq(2, 4)]
r3 = v1[2:4]
r3 = v1[2:2]
v1%%2 == 0
#벡터 연산
rm(list=ls())
v1 <- seq(2, 10, 2)
rm(list=ls())
v1 <- seq(1,5)
r1 = v1[3] #3번 인덱스
r2 = v1[-3] #3번 인덱스를 제외하고 모두
r3 = v1[2:4]
#가져오는 것에 따라 타입이 달라진다 (스칼라 or 벡터)
r4 = v1[v1%%2 == 0]
names(v1) <- c('A', 'B', 'C', 'D', 'E')
# >> Named int로 변하게 되는데 인덱스번호로도 사용할 수 있고 이름으로도 사용할 수 있다는 뜻이다.
r5 = v1['B']
r6 = v1[2]
rm(list=ls())
v1 <- seq(2, 10, 2)
v2 <- rep(2, 5)
v3 <- v1 + v2 #같은 element 위치에 있는 것끼리 연산하게 됨
v4 <- v1 %/% v2
v5 <- v1 ^ v2
x <- c(1, 4, 8)
y <- c(2, 3)
z <- t(y) #전치행렬: 행과 열의 개념을 바꿔놓음
m <- x %*% z #행렬곱, 행 * 열
rm(list = ls())
m1 = matrix(seq(1, 10), nrow = 5)
View(m1)
m2 = matrix(seq(1, 6), ncol = 3)
View(m2)
m1 = matrix(seq(1, 10), nrow = 5, byrow = TRUE)
m3 = rbind(seq(1, 3), seq(4, 6)) # row bind
View(m3)
#하나 이상의 스칼라(=길이가 1인 벡터) 원소들을 갖는 단순한 형태의 집합
#숫자, 문자, 논리형 데이터를 원소(Element)로 사용할 수 있음
#동일한 자료형을 갖는 값들의 집합으로 하나의 열(Column)로 구성됨
#벡터 생성 함수: c(value1, value2 ...), seq(form, to, by), rep(x, times, each) (seq = sequence, rep = repeat)
#벡터 생성
rm(list = ls())
iv <- c(1, 2, 3)
cv <- c('A', 'B', 'C')
bv <- c(TRUE, FALSE)
t <- c(1, 2, 3, 4)
fv <- c(3.4, 2.5, 8)
icv <- c(iv, cv, bv)
#icv 서로 다른 타입을 연결할 경우 문자열 취급되어 연결됨
rm(list = ls())
v1 = seq(1, 5) # == v11 = 1:5
v2 = seq(1, 10, 2)
v3 = seq(1, 10, length = 4) # 4개를 생성한다. 간격은 알아서 조절
v4 = seq(1, 3, length = 5)
rm(list = ls())
v1 = rep(1, 5)
v2 = rep(1, time = 5)
v3 = rep(3:5, time = 3)
v4 = rep(3:5, each = 2)
v5 = rep(seq(1,5,2), 2)
# c, seq, rep
#벡터 연산
rm(list=ls())
v1 <- seq(2, 10, 2)
v2 <- rep(2, 5)
v3 <- v1 + v2 #같은 element 위치에 있는 것끼리 연산하게 됨
v4 <- v1 %/% v2
v5 <- v1 ^ v2
x <- c(1, 4, 8)
y <- c(2, 3)
z <- t(y) #전치행렬: 행과 열의 개념을 바꿔놓음
m <- x %*% z #행렬곱, 행 * 열
rm(list=ls())
v1 <- rep(3, 6) # 길이(time)가 7일 때, 두 객체의 길이가 서로 배수관계에 있지 않는다고 오류가 뜬다
v2 <- c(1, 2, 3)
v3 <- v1 + v2
v4 <- v2 + 3 # 각 element에 3을 더해준다
#인덱싱 (기존에 알고있던 index 0부터가 아님)
rm(list=ls())
v1 <- seq(1,5)
r1 = v1[3] #3번 인덱스
r2 = v1[-3] #3번 인덱스를 제외하고 모두
r3 = v1[2:4]
#가져오는 것에 따라 타입이 달라진다 (스칼라 or 벡터)
r4 = v1[v1%%2 == 0] #TRUE인 것만 가져오게 됨
names(v1) <- c('A', 'B', 'C', 'D', 'E')
# >> Named int로 변하게 되는데 인덱스번호로도 사용할 수 있고 이름으로도 사용할 수 있다는 뜻이다.
r5 = v1['B'] #이름
r6 = v1[2] #인덱스 번호
#인덱싱 (기존에 알고있던 index 0부터가 아님)
#rm(list=ls())
v1 <- seq(1,5)
#하나 이상의 스칼라(=길이가 1인 벡터) 원소들을 갖는 단순한 형태의 집합
#숫자, 문자, 논리형 데이터를 원소(Element)로 사용할 수 있음
#동일한 자료형을 갖는 값들의 집합으로 하나의 열(Column)로 구성됨
#벡터 생성 함수: c(value1, value2 ...), seq(form, to, by), rep(x, times, each) (seq = sequence, rep = repeat)
#벡터 생성
rm(list = ls())
iv <- c(1, 2, 3)
cv <- c('A', 'B', 'C')
bv <- c(TRUE, FALSE)
t <- c(1, 2, 3, 4)
fv <- c(3.4, 2.5, 8)
icv <- c(iv, cv, bv)
#icv 서로 다른 타입을 연결할 경우 문자열 취급되어 연결됨
rm(list = ls())
v1 = seq(1, 5) # == v11 = 1:5
v2 = seq(1, 10, 2)
v3 = seq(1, 10, length = 4) # 4개를 생성한다. 간격은 알아서 조절
v4 = seq(1, 3, length = 5)
rm(list = ls())
v1 = rep(1, 5)
v2 = rep(1, time = 5)
v3 = rep(3:5, time = 3)
v4 = rep(3:5, each = 2)
v5 = rep(seq(1,5,2), 2)
# c, seq, rep
#벡터 연산
rm(list=ls())
v1 <- seq(2, 10, 2)
v2 <- rep(2, 5)
v3 <- v1 + v2 #같은 element 위치에 있는 것끼리 연산하게 됨
v4 <- v1 %/% v2
v5 <- v1 ^ v2
x <- c(1, 4, 8)
y <- c(2, 3)
z <- t(y) #전치행렬: 행과 열의 개념을 바꿔놓음
m <- x %*% z #행렬곱, 행 * 열
rm(list=ls())
v1 <- rep(3, 6) # 길이(time)가 7일 때, 두 객체의 길이가 서로 배수관계에 있지 않는다고 오류가 뜬다
v2 <- c(1, 2, 3)
v3 <- v1 + v2
v4 <- v2 + 3 # 각 element에 3을 더해준다
#인덱싱 (기존에 알고있던 index 0부터가 아님)
#rm(list=ls())
v1 <- seq(1,5)
r1 = v1[3] #3번 인덱스
r2 = v1[-3] #3번 인덱스를 제외하고 모두
r3 = v1[2:4]
#가져오는 것에 따라 타입이 달라진다 (스칼라 or 벡터)
r4 = v1[v1%%2 == 0] #TRUE인 것만 가져오게 됨
names(v1) <- c('A', 'B', 'C', 'D', 'E')
# >> Named int로 변하게 되는데 인덱스번호로도 사용할 수 있고 이름으로도 사용할 수 있다는 뜻이다.
r5 = v1['B'] #이름
r6 = v1[2] #인덱스 번호
v1 <- rep(3, 7) # 길이(time)가 7일 때, 두 객체의 길이가 서로 배수관계에 있지 않는다고 오류가 뜬다
#하나 이상의 스칼라(=길이가 1인 벡터) 원소들을 갖는 단순한 형태의 집합
#숫자, 문자, 논리형 데이터를 원소(Element)로 사용할 수 있음
#동일한 자료형을 갖는 값들의 집합으로 하나의 열(Column)로 구성됨
#벡터 생성 함수: c(value1, value2 ...), seq(form, to, by), rep(x, times, each) (seq = sequence, rep = repeat)
#벡터 생성
rm(list = ls())
iv <- c(1, 2, 3)
cv <- c('A', 'B', 'C')
bv <- c(TRUE, FALSE)
t <- c(1, 2, 3, 4)
fv <- c(3.4, 2.5, 8)
icv <- c(iv, cv, bv)
#icv 서로 다른 타입을 연결할 경우 문자열 취급되어 연결됨
rm(list = ls())
v1 = seq(1, 5) # == v11 = 1:5
v2 = seq(1, 10, 2)
v3 = seq(1, 10, length = 4) # 4개를 생성한다. 간격은 알아서 조절
v4 = seq(1, 3, length = 5)
rm(list = ls())
v1 = rep(1, 5)
v2 = rep(1, time = 5)
v3 = rep(3:5, time = 3)
v4 = rep(3:5, each = 2)
v5 = rep(seq(1,5,2), 2)
# c, seq, rep
#벡터 연산
rm(list=ls())
v1 <- seq(2, 10, 2)
v2 <- rep(2, 5)
v3 <- v1 + v2 #같은 element 위치에 있는 것끼리 연산하게 됨
v4 <- v1 %/% v2
v5 <- v1 ^ v2
x <- c(1, 4, 8)
y <- c(2, 3)
z <- t(y) #전치행렬: 행과 열의 개념을 바꿔놓음
m <- x %*% z #행렬곱, 행 * 열
rm(list=ls())
v1 <- rep(3, 7) # 길이(time)가 7일 때, 두 객체의 길이가 서로 배수관계에 있지 않는다고 오류가 뜬다
v2 <- c(1, 2, 3)
v3 <- v1 + v2
v4 <- v2 + 3 # 각 element에 3을 더해준다
#인덱싱 (기존에 알고있던 index 0부터가 아님)
#rm(list=ls())
v1 <- seq(1,5)
r1 = v1[3] #3번 인덱스
r2 = v1[-3] #3번 인덱스를 제외하고 모두
r3 = v1[2:4]
#가져오는 것에 따라 타입이 달라진다 (스칼라 or 벡터)
r4 = v1[v1%%2 == 0] #TRUE인 것만 가져오게 됨
names(v1) <- c('A', 'B', 'C', 'D', 'E')
# >> Named int로 변하게 되는데 인덱스번호로도 사용할 수 있고 이름으로도 사용할 수 있다는 뜻이다.
r5 = v1['B'] #이름
r6 = v1[2] #인덱스 번호
#matrix(행렬)
#데이터의 형태가 2차원으로 행(row)과 열(column)으로 구성
#하나의 데이터 유형만 가능, 역행렬은 solve()로 구함
#행렬 생성 함수
#matirx(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
#rbind(vectors or matrices), cbinde(vectors or matrices)
#byrow = FALSE면 열방향(default도 열방향), TURE > 행방향을 우선으로 채우게 됨
rm(list = ls())
m1 = matrix(seq(1, 10), nrow = 5, byrow = TRUE)
m2 = matrix(seq(1, 6), ncol = 3)
m3 = rbind(seq(1, 3), seq(4, 6), seq(7, 10)) # row bind
View(m3)
#각 seq길이가 다를 때, number of columns of result is not a multiple of vector length
m4 = cbind(seq(1, 3), seq(4, 6))
View(m4)
m <- matrix(seq(1, 12), nrow = 4, ncol = 3)
rm(list=ls())
m <- matrix(seq(1, 12), nrow = 4, ncol = 3)
View(m)
m
m1 <- m[2, 3]
m2 <- m[3, ]
m3 <- m[, -2]
m4 <- m[c(2, 3), 2]
m5 <- m[c(TRUE, FALSE, FALSE, TRUE), ]
m5
rm(list = ls())
a1 = array(1:12, dim = c(3,2,2))
a1
a2 = array(1:6, dim=c(2, 3))
View(a2)
a2
rm(list = ls())
name <- c("tom", "jerry", "cindy", "mark")
gender <- c('f', 'm', 'f', 'm')
kor <- c(90, 100, 80, 95)
eng <- c(90, 95, 100, 80)
df1 <- data.frame(name, gender, kor, eng)
View(df1)
df2 <- data.frame(matrix(seq(1,9), nrow = 3))
View(df2)
df3 <- data.frame(gender = c('f', 'm', 'f', 'm')
score = c(90, 100, 80, 95),
stringAsFactors = TRUE)
df3 <- data.frame(gender = c('f', 'm', 'f', 'm'),
score = c(90, 100, 80, 95),
stringAsFactors = TRUE)
View(df3)
str(df3)
df3 <- data.frame(gender = c('f', 'm', 'f', 'm'),
score = c(90, 100, 80, 95),
stringsAsFactors = TRUE)
str(df3)
rm(list = ls())
name <- c("tom", "jerry", "cindy", "mark")
gender <- c('f', 'm', 'f', 'm')
kor <- c(90, 100, 80, 95)
eng <- c(90, 95, 100, 80)
df1 <- data.frame(name, gender, kor, eng)
View(df1)
df1
df1[1, 3]
v1 <- df1[1, 3]
df1[2, ]
v2 <- df1[2, ]
View(v2)
v3 <- df[,'name']
v3 <- df1[,'name']
v4 <- df1$name
df2 <- df1[1]
View(df1)
View(df2)
df3 <- df1['name']
View(df2)
View(df3)
v4 <- df1[[1]] # 1번 열, vector타입 리턴
df4 <- df1[seq(1, 3), c(1, 2)]
View(df4)
df4
df5 <- df1[, 2:4]
View(df5)
df6 <- df1[1:3]
View(df6)
df6
df7 <- df1[-2]
df7
df8 <- df1[-c(1, 3)]
df8
df8 <- df1[-c(1, 3, 4)]
df8
